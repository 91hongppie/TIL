|             |                             TCP                              |                             UDP                              |
| :---------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 신뢰성 제공 | 내용 유실 없다.<br />- 내용상의 이빠짐이 없다<br />- 순서가 보장된다. |    내용 유실 있을수 있다.<br />- 순서도 보장되지 않는다.     |
|    속도     | 고의적 지연이 존재<br />- 패킷 수신 순서로 인해서 지연 발생<br />- 혼잡 제어 때문에 |                     고의적 지연은 없다.                      |
|  전송 단위  | 바이트(Byte)<br />send() 와 recv()에 상관없이<br />모든 정보를 받는다. | 패킷(데이터그램)<br />send() 함수 호출 단위<br />- send()로 두번 보내고 recv()를 한번만 호출하면<br /> 하나의 데이터그램만 받는다. |



# TCP

- Reliable Network
- 내용 변조 탐지
  - 패킷이 보내질 때 중간에 잡음이나 노이즈, 인터피어런스에 의해 패킷의 내용이 변화될 수 있다.
  - 보안 공격을 탐지하지는 않는다.
  - 고의적이지 않은 이유로 바뀌는 것을 탐지 가능하다.
- 혼잡 제어
  - 네트워크가 혼잡이 심할 때 패킷을 기다렸다가 보내서 혼잡을 제어한다.
- 흐름 제어
  - 패킷을 수신하는 측의 버퍼가 가득차서 넘치게 되는 경우에 수신측에서 송신측으로 패킷을 보내지말라고 요청할수있다
- 포트(사서함) 개념 지원
  - 응용 구분

|                     | 송신측                                                       | 수신측                                                       |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 응용계층(세션 HTTP) | 1.HTML바디에 HTTP 헤더를 붙인 문서를 만들어 전송계층에 전송해달라고 전달 | 10.HTTP 헤더를 제거하고 html문서를 가지고 브라우저를 통해 내용을 보여준다. |
| 전송계층(TCP)       | 2.응용계층에 받은 문서 위에 TCP헤더를 추가로 붙여서 네트워크계층에 전달 | 9.빠진 패킷은 없는지 분석하고 TCP헤더를 제거하고 응용 계층으로 전달 |
| 네트워크계층(IP)    | 3.전달받은 문서 위에  IP헤더를 추가로 붙여서 링크계층에 전달한다.(Source IP와 DestinationIP가 헤더에 포함된다.) | 8.IP 헤더를 제거하고 전송계층으로 전달                       |
| 링크계층(이더넷)    | 4.전달받은 문서 위에 이더넷 헤더를 추가로 붙여서 물리계층에 전달 | 7.이더넷헤드를 제거하고 네트워크 계층으로 전달               |
| 물리계층            | 5.전달받은 내용을 전기적인 신호로 바꾼다.                    | 6.수신 받은 전기적인 신호를 데이터 형태로 변환               |

## TCP 헤더

- TCP헤더는 바이너리 형태의 구조 
- 첫번째 32비트에는 Source Port 번호(16비트)와 Destination Port 번호(16비트)가 포함된다.
- 두번째 32비트에는 Sequence Number와 ACK Number가 포함된다.
  - 바이트마다 번호를 붙인다.100바이트를 보내면 Sequence Number가 100 증가한다.
  - A 측면 - Sequence 42, ACK 77 'Hello' == 42번 문자부터 보내고 있고 77번 문자부터 받을 차례다. Hello를 보내면 H =42, e=43, l=44, l=45, o=46 
  - B 측면 - Sequence 77, ACK 47 'Hi' == 77번 문자부터 보내고 있고 47번 문자부터 받을 차례다. Hi를 보내면 H=77, i=78
    - 응용계층의 응답을 위해 B측면에서 0.5초 정도 ACK을 지연시킨다. 그 이후에도 응답이 없으면 아무 내용 없이 ACK을 보낸다.
  - A 측면 - Sequence 47, ACK 79 ''
- 세번째 32비트
  - 앞의 16비트의 그 앞에는 헤더 길이정보가 들어간다.
  - 그 다음에는 잘게 쪼개서 플래그 정보가 들어간다.
    - 맺고 끊는 제어패킷인지 아닌지에 대한 정보가 들어간다.
  - 그 다음의 16비트에는 Receive Window 정보가 들어간다.
    - 수신 가능한 버퍼 크기
    - 수신측이 데이터를 받을수 없을때 송신측에서 계속 데이터를 보내게 되면 네트워크가 낭비된다. 그 낭비를 막기위해 Receive Window가 존재한다.
    - 흐름제어
- 다음의 16비트
  - Checksum
    - TCP에도 있고 UDP에도 있다.
    - 내용 변조 탐지를 위해 존재한다.
  - Checksum 더하기
    - 2진 더하기
    - 무조건 4자리수만 나올수밖에 없다.
    - 0110 + 0011 = 1001 일반 2진 더하기와 같다. 올림이 없기 때문에
    - 1101 + 1011
      - 일반 더하기 = 11000
      - Checksum 더하기 = 1001 올림이 되는 수를 한번 더 더한다.
  - 전체를 모두 더했을때 111111로만 계속되는 수를 만들수 있도록 해당 부분을 조작한다.
- 다음으로 실제 내용이 들어간다.(Payload 또는 Body라고 한다.)

## 소켓 VS 포트

- 소켓 여러개가 하나의 포트에 연결될 수 있다.

# UDP